# 閉包テーブル入門: 階層構造をデータベースで表現する

## 1. はじめに
データベースで本の分類のような階層構造を扱うとき、「閉包テーブル」という設計方法があります。
この資料では、本の分類を例に、閉包テーブルの基本を学んでいきましょう。

## 2. 本の分類例
以下のような本の分類があるとします：

```
書籍
├── 小説
│   ├── ミステリー
│   └── 恋愛小説
└── 実用書
    ├── 料理
    │   ├── 和食
    │   └── イタリアン
    └── プログラミング
```

## 3. テーブル構造

### 3.1 基本テーブル
まず、カテゴリ名を保存する基本テーブルを作ります：

```sql
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);
```

### 3.2 閉包テーブル
次に、すべての関係を保存する閉包テーブルを作ります：

```sql
CREATE TABLE category_closure (
    descendant_id INTEGER NOT NULL,  -- 自分のID
    ancestor_id INTEGER NOT NULL,    -- 関係のある上位者のID
    depth INTEGER NOT NULL,          -- 自分と上位者との距離
    PRIMARY KEY (descendant_id, ancestor_id),
    FOREIGN KEY (descendant_id) REFERENCES categories(id),
    FOREIGN KEY (ancestor_id) REFERENCES categories(id)
);
```

## 4. データの見方

### 4.1 基本的な考え方
閉包テーブルでは以下の3つの情報を記録します：

1. **descendant_id**: 「自分」のID
2. **ancestor_id**: 「関係のある上位者」のID
3. **depth**: 「自分」と「上位者」の距離
   - 0: 自分自身
   - 1: 直接の上位者
   - 2: 上位者の上位者
   - 3: さらに上の上位者...

### 4.2 具体例：イタリアン料理の場合
イタリアン料理（ID:9）の場合を見てみましょう：

| descendant_id (自分) | ancestor_id (上位者) | depth | 意味 |
|---------------------|---------------------|-------|------|
| 9 (イタリアン)       | 9 (イタリアン)        | 0     | 自分自身 |
| 9 (イタリアン)       | 6 (料理)            | 1     | 直接の上位者 |
| 9 (イタリアン)       | 3 (実用書)          | 2     | 上位者の上位者 |
| 9 (イタリアン)       | 1 (書籍)            | 3     | 最上位者 |

## 5. よく使うSQL例

### 5.1 特定のカテゴリの下にある全ての本を取得
```sql
-- 例：実用書(ID:3)の下にある全ての本を取得
SELECT 
    c.name as カテゴリ名,
    cc.depth as 深さ
FROM categories c
JOIN category_closure cc ON c.id = cc.descendant_id
WHERE cc.ancestor_id = 3
ORDER BY cc.depth;
```

### 5.2 特定のカテゴリの上位カテゴリを全て取得
```sql
-- 例：イタリアン(ID:9)の上位カテゴリを全て取得
SELECT 
    c.name as 上位カテゴリ名,
    cc.depth as 深さ
FROM categories c
JOIN category_closure cc ON c.id = cc.ancestor_id
WHERE cc.descendant_id = 9
ORDER BY cc.depth;
```

### 5.3 直接の子カテゴリのみ取得
```sql
-- 例：料理(ID:6)の直接の子カテゴリを取得
SELECT 
    c.name as 子カテゴリ名
FROM categories c
JOIN category_closure cc ON c.id = cc.descendant_id
WHERE 
    cc.ancestor_id = 6
    AND cc.depth = 1;
```

## 6. メリット・デメリット

### メリット
1. 階層構造の検索が高速
2. 複雑な再帰クエリが不要
3. 任意の深さの関係を簡単に取得可能

### デメリット
1. データ量が多くなる
2. データ更新時の処理が複雑

## 7. まとめ
閉包テーブルは、「あり得るすべての関係をレコードで持つ」という考え方です。
データ量は増えますが、検索が高速で、複雑な階層構造を扱いやすくなります。

---
参考：本ドキュメントで使用した完全なサンプルデータは以下の通りです：

```sql
-- カテゴリの基本データを作成
INSERT INTO categories (name)
VALUES ('書籍'),           -- id: 1
       ('小説'),           -- id: 2
       ('実用書'),         -- id: 3
       ('ミステリー'),     -- id: 4
       ('恋愛小説'),       -- id: 5
       ('料理'),           -- id: 6
       ('プログラミング'), -- id: 7
       ('和食'),           -- id: 8
       ('イタリアン');
-- id: 9

-- 閉包テーブルにデータを挿入（完全な階層関係を表現）
INSERT INTO category_closure (ancestor_id, descendant_id, depth)
VALUES
   -- 自己参照（すべてのノードは自分自身への参照を持つ）
   (1, 1, 0), -- 書籍 → 書籍
   (2, 2, 0), -- 小説 → 小説
   (3, 3, 0), -- 実用書 → 実用書
   (4, 4, 0), -- ミステリー → ミステリー
   (5, 5, 0), -- 恋愛小説 → 恋愛小説
   (6, 6, 0), -- 料理 → 料理
   (7, 7, 0), -- プログラミング → プログラミング
   (8, 8, 0), -- 和食 → 和食
   (9, 9, 0), -- イタリアン → イタリアン

   -- 第1階層の関係
   (1, 2, 1), -- 書籍 → 小説
   (1, 3, 1), -- 書籍 → 実用書

   -- 第2階層の関係
   (1, 4, 2), -- 書籍 → ミステリー
   (1, 5, 2), -- 書籍 → 恋愛小説
   (1, 6, 2), -- 書籍 → 料理
   (1, 7, 2), -- 書籍 → プログラミング

   -- 第3階層の関係
   (1, 8, 3), -- 書籍 → 和食
   (1, 9, 3), -- 書籍 → イタリアン

   -- 小説の下位カテゴリとの関係
   (2, 4, 1), -- 小説 → ミステリー
   (2, 5, 1), -- 小説 → 恋愛小説

   -- 実用書の下位カテゴリとの関係
   (3, 6, 1), -- 実用書 → 料理
   (3, 7, 1), -- 実用書 → プログラミング
   (3, 8, 2), -- 実用書 → 和食（追加：料理を通じた関係）
   (3, 9, 2), -- 実用書 → イタリアン（追加：料理を通じた関係）

   -- 料理の下位カテゴリとの関係
   (6, 8, 1), -- 料理 → 和食
   (6, 9, 1); -- 料理 → イタリアン
```
